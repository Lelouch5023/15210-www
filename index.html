<!--#set var="root" value=""-->
<!--#set var="title" value="Parallel and Sequential Data Structures and Algorithms"-->
<!--#include virtual="includes/headers.html"-->
<body>
  <!--#set var="page" value="home"-->
  <!--#include virtual="includes/page-header.html"-->
  <h2>Announcements</h2>
  <ol id="announcements">
    <li>MIST Lab is now <a href="https://autolab.cs.cmu.edu/15210-s13/mistlab">
      available</a>! It is due Monday, April 1.</li>
    <li>Exam I <a href="solutions/exam1-sol.pdf">solutions</a> are now available.</li>

    <li>Thesauruslab
      <a href="solutions/thesauruslab/code.pdf">code solutions</a> are now available.</li>
    <li>Babblelab <a href="solutions/babblelab/babblelab-sol.pdf">written solutions</a>
      and <a href="solutions/babblelab/code.pdf">code solutions</a> are now available.</li>
    <li>Online documentation for the
      210 library is now <a href="docs">available</a>.</li>
  </ol>
  <h2>Overview</h2>
  <p>
15-210 aims to teach methods for designing, analyzing, and programming
sequential and parallel algorithms and data structures. The emphasis is on
teaching fundamental concepts applicable across a wide variety of problem
domains, and transferable across a reasonably broad set of programming
languages and computer architectures. This course also includes a
significant programming component in which students will program concrete
examples from domains such as engineering, scientific computing, graphics,
data mining, and information retrieval (web search).
  </p>
  <p>
Unlike a traditional
introduction to algorithms and data structures, this course puts an emphasis
on <em>parallel thinking</em> &mdash; i.e., thinking about how algorithms
can do multiple things at once instead of one at a time. The course follows
up on material learned in 15-122 and 15-150 but goes into significantly more
depth on algorithmic issues.
  </p>
  <p>The following concepts are covered:</p>
  <ul id="concepts" class="clearfix">
    <li>
      <h3>Problem vs. Algorithm</h3>
      <p>
A <em>problem</em> defines an interface while an <em>algorithm</em>
defines a particular method to solve the problem. For example, quicksort
is an algorithm to solve the sorting problem. Being able to cleanly define
a problem is key in the process of putting together large programs and in
reusing their components.
      </p>
    </li>
    <li>
      <h3>Asymptotic Analysis</h3>
      <p>
In this class, we analyze performance in terms of work,
span, and space using <em>big-O</em> analysis. We cover a variety of
techniques for analyzing asymptotic performance including solving
recurrences, randomized analysis, and various counting arguments.
      </p>
    </li>
    <li>
      <h3>Techniques in Algorithm Design</h3>
      <p>
We cover techniques that play a key role in the design of most algorithms
and data structures, including: collections (sets, sequences, priority
queues, ...), divide-and-conquer, contraction, the greedy method,
balanced trees, hashing, sparse matrices, and dynamic programming.
      </p>
    </li>
  </ul>
  <!--#include virtual="includes/page-footer.html"-->
</body>
</html>
